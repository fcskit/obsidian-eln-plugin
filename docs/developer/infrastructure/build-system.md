# Build System

The Build System for the Obsidian ELN Plugin provides a modern, efficient development workflow using esbuild for fast compilation, hot-reload for development, and optimized production builds.

## üèóÔ∏è Build Architecture

```typescript
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  Build System                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ
‚îÇ  ‚îÇ    esbuild      ‚îÇ  ‚îÇ       Watch Mode            ‚îÇ‚îÇ
‚îÇ  ‚îÇ  Configuration  ‚îÇ  ‚îÇ                             ‚îÇ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ
‚îÇ  ‚îÇ    CSS Build    ‚îÇ  ‚îÇ    Asset Pipeline           ‚îÇ‚îÇ
‚îÇ  ‚îÇ                 ‚îÇ  ‚îÇ                             ‚îÇ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ
‚îÇ  ‚îÇ  Release Build  ‚îÇ  ‚îÇ    Development Tools        ‚îÇ‚îÇ
‚îÇ  ‚îÇ                 ‚îÇ  ‚îÇ                             ‚îÇ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üì¶ Core Configuration

### Main esbuild Configuration

```javascript
// esbuild.config.mjs
import esbuild from 'esbuild';
import process from 'process';
import builtins from 'builtin-modules';

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/`;

const prod = (process.argv[2] === 'production');

const context = await esbuild.context({
    banner: {
        js: banner,
    },
    entryPoints: ['src/main.ts'],
    bundle: true,
    external: [
        'obsidian',
        'electron',
        '@codemirror/autocomplete',
        '@codemirror/collab',
        '@codemirror/commands',
        '@codemirror/language',
        '@codemirror/lint',
        '@codemirror/search',
        '@codemirror/state',
        '@codemirror/view',
        '@lezer/common',
        '@lezer/highlight',
        '@lezer/lr',
        ...builtins
    ],
    format: 'cjs',
    target: 'es2018',
    logLevel: 'info',
    sourcemap: prod ? false : 'inline',
    treeShaking: true,
    outfile: 'main.js',
    minify: prod,
    define: {
        'process.env.NODE_ENV': prod ? '"production"' : '"development"',
        'global': 'globalThis',
    },
    plugins: [
        // Plugin for handling TypeScript decorators
        {
            name: 'decorator-metadata',
            setup(build) {
                build.onLoad({ filter: /\.ts$/ }, async (args) => {
                    const source = await fs.readFile(args.path, 'utf8');
                    
                    // Enable experimental decorators support
                    const result = await esbuild.transform(source, {
                        loader: 'ts',
                        experimentalDecorators: true,
                        emitDecoratorMetadata: true,
                        target: 'es2018'
                    });
                    
                    return {
                        contents: result.code,
                        loader: 'js'
                    };
                });
            }
        },
        
        // Plugin for development hot reload
        !prod && {
            name: 'hot-reload',
            setup(build) {
                build.onEnd(result => {
                    if (result.errors.length === 0) {
                        console.log('‚úÖ Build completed successfully');
                        
                        // Trigger hot reload in Obsidian
                        if (process.env.HOT_RELOAD === 'true') {
                            triggerHotReload();
                        }
                    }
                });
            }
        },
        
        // Plugin for bundle analysis
        prod && {
            name: 'bundle-analyzer',
            setup(build) {
                build.onEnd(result => {
                    if (result.errors.length === 0) {
                        analyzeBundleSize();
                    }
                });
            }
        }
    ].filter(Boolean),
});

if (prod) {
    await context.rebuild();
    process.exit(0);
} else {
    await context.watch();
    console.log('üëÄ Watching for changes...');
}
```

### TypeScript Configuration

```json
// tsconfig.json
{
    "compilerOptions": {
        "baseUrl": ".",
        "inlineSourceMap": true,
        "inlineSources": true,
        "module": "ESNext",
        "target": "ES6",
        "allowJs": true,
        "noImplicitAny": false,
        "moduleResolution": "node",
        "importHelpers": true,
        "isolatedModules": true,
        "strictNullChecks": true,
        "lib": [
            "DOM",
            "ES6"
        ],
        "experimentalDecorators": true,
        "emitDecoratorMetadata": true,
        "skipLibCheck": true,
        "paths": {
            "@/*": ["src/*"],
            "@core/*": ["src/core/*"],
            "@ui/*": ["src/ui/*"],
            "@utils/*": ["src/utils/*"],
            "@types/*": ["src/types/*"]
        }
    },
    "include": [
        "src/**/*",
        "*.d.ts"
    ],
    "exclude": [
        "node_modules",
        "**/*.test.ts",
        "tests/**/*"
    ]
}
```

## üé® CSS Build Pipeline

### CSS Build Configuration

```javascript
// build-css.mjs
import fs from 'fs/promises';
import path from 'path';
import { createRequire } from 'module';

const require = createRequire(import.meta.url);

// CSS Processing Pipeline
export class CSSBuildPipeline {
    constructor(options = {}) {
        this.inputDir = options.inputDir || 'src/styles';
        this.outputFile = options.outputFile || 'styles.css';
        this.minify = options.minify || false;
        this.sourcemap = options.sourcemap || false;
    }
    
    async build() {
        console.log('üé® Building CSS...');
        
        try {
            // Read all CSS files
            const cssFiles = await this.findCSSFiles();
            
            // Process and concatenate
            let combinedCSS = '';
            
            for (const file of cssFiles) {
                const content = await fs.readFile(file, 'utf8');
                const processed = await this.processCSS(content, file);
                combinedCSS += `/* ${path.relative('.', file)} */\n${processed}\n\n`;
            }
            
            // Apply post-processing
            const finalCSS = await this.postProcess(combinedCSS);
            
            // Write output
            await fs.writeFile(this.outputFile, finalCSS);
            
            console.log(`‚úÖ CSS built successfully: ${this.outputFile}`);
            
        } catch (error) {
            console.error('‚ùå CSS build failed:', error);
            throw error;
        }
    }
    
    async findCSSFiles() {
        const files = [];
        
        // Define build order for CSS files
        const orderedFiles = [
            'base/reset.css',
            'base/variables.css',
            'base/typography.css',
            'components/*.css',
            'layouts/*.css',
            'themes/*.css',
            'utilities/*.css'
        ];
        
        for (const pattern of orderedFiles) {
            const matches = await this.globFiles(pattern);
            files.push(...matches);
        }
        
        return files;
    }
    
    async processCSS(content, filePath) {
        // Variable substitution
        content = this.processVariables(content);
        
        // Nested CSS processing (basic implementation)
        content = this.processNesting(content);
        
        // Import resolution
        content = await this.resolveImports(content, filePath);
        
        return content;
    }
    
    processVariables(css) {
        // Process CSS custom properties and our own variable system
        return css.replace(/var\(--([^)]+)\)/g, (match, varName) => {
            // Keep CSS custom properties as-is
            return match;
        });
    }
    
    processNesting(css) {
        // Simple nested CSS processing
        // This is a basic implementation - in production you might use PostCSS
        return css.replace(/([^{}]+)\s*{\s*([^{}]*)\s*([^{}]+\s*{[^}]*}\s*)*}/g, (match, selector, props, nested) => {
            if (!nested) return match;
            
            const nestedRules = nested.match(/([^{}]+)\s*{([^}]*)}/g) || [];
            const processedNested = nestedRules.map(rule => {
                const [, nestedSelector, nestedProps] = rule.match(/([^{}]+)\s*{([^}]*)}/) || [];
                if (!nestedSelector || !nestedProps) return '';
                
                const combinedSelector = selector.trim() + ' ' + nestedSelector.trim();
                return `${combinedSelector} {\n${nestedProps}\n}`;
            }).join('\n');
            
            return `${selector} {\n${props}\n}\n${processedNested}`;
        });
    }
    
    async resolveImports(css, basePath) {
        const importRegex = /@import\s+['"]([^'"]+)['"];?/g;
        let match;
        
        while ((match = importRegex.exec(css)) !== null) {
            const importPath = match[1];
            const fullPath = path.resolve(path.dirname(basePath), importPath);
            
            try {
                const importedContent = await fs.readFile(fullPath, 'utf8');
                const processedImport = await this.processCSS(importedContent, fullPath);
                css = css.replace(match[0], `/* Imported from ${importPath} */\n${processedImport}`);
            } catch (error) {
                console.warn(`Warning: Could not resolve import ${importPath}`);
            }
        }
        
        return css;
    }
    
    async postProcess(css) {
        if (this.minify) {
            css = this.minifyCSS(css);
        }
        
        // Add banner
        const banner = `/*! Obsidian ELN Plugin - Built ${new Date().toISOString()} */\n`;
        return banner + css;
    }
    
    minifyCSS(css) {
        return css
            .replace(/\/\*[\s\S]*?\*\//g, '') // Remove comments
            .replace(/\s+/g, ' ') // Collapse whitespace
            .replace(/;\s*}/g, '}') // Remove last semicolon in blocks
            .replace(/{\s+/g, '{') // Remove space after opening brace
            .replace(/\s+{/g, '{') // Remove space before opening brace
            .replace(/}\s+/g, '}') // Remove space after closing brace
            .trim();
    }
    
    async globFiles(pattern) {
        // Simple glob implementation
        const baseDir = this.inputDir;
        const files = [];
        
        if (pattern.includes('*')) {
            const dirPath = path.join(baseDir, pattern.replace('*.css', ''));
            try {
                const dirFiles = await fs.readdir(dirPath);
                for (const file of dirFiles) {
                    if (file.endsWith('.css')) {
                        files.push(path.join(dirPath, file));
                    }
                }
            } catch (error) {
                // Directory doesn't exist, skip
            }
        } else {
            const filePath = path.join(baseDir, pattern);
            try {
                await fs.access(filePath);
                files.push(filePath);
            } catch (error) {
                // File doesn't exist, skip
            }
        }
        
        return files;
    }
}

// Main build function
async function buildCSS() {
    const pipeline = new CSSBuildPipeline({
        inputDir: 'src/styles',
        outputFile: 'styles.css',
        minify: process.argv.includes('--minify'),
        sourcemap: process.argv.includes('--sourcemap')
    });
    
    await pipeline.build();
}

// Watch mode for CSS
export async function watchCSS() {
    const chokidar = require('chokidar');
    
    console.log('üëÄ Watching CSS files...');
    
    const watcher = chokidar.watch('src/styles/**/*.css', {
        persistent: true
    });
    
    let building = false;
    
    const rebuild = async () => {
        if (building) return;
        building = true;
        
        try {
            await buildCSS();
            console.log('üé® CSS rebuilt successfully');
        } catch (error) {
            console.error('‚ùå CSS rebuild failed:', error);
        } finally {
            building = false;
        }
    };
    
    watcher.on('change', rebuild);
    watcher.on('add', rebuild);
    watcher.on('unlink', rebuild);
    
    // Initial build
    await rebuild();
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
    if (process.argv.includes('--watch')) {
        watchCSS();
    } else {
        buildCSS();
    }
}
```

### CSS Watch Mode

```javascript
// watch-css.mjs
import { watchCSS } from './build-css.mjs';

console.log('üé® Starting CSS watch mode...');
watchCSS().catch(console.error);
```

## üöÄ Development Scripts

### Package.json Scripts

```json
{
    "scripts": {
        "dev": "npm run build:css && node esbuild.config.mjs",
        "build": "npm run build:css && node esbuild.config.mjs production",
        "build:css": "node build-css.mjs",
        "build:css:watch": "node watch-css.mjs",
        "watch": "npm run build:css && npm run dev",
        "watch:all": "concurrently \"npm run build:css:watch\" \"npm run dev\"",
        "clean": "rm -f main.js styles.css *.map",
        "lint": "eslint src --ext .ts,.js",
        "lint:fix": "eslint src --ext .ts,.js --fix",
        "type-check": "tsc --noEmit",
        "test": "jest",
        "test:watch": "jest --watch",
        "version": "node version-bump.mjs",
        "build:release": "npm run clean && npm run lint && npm run type-check && npm run test && npm run build",
        "package": "node build-release.mjs",
        "sync": "node sync-from-vault.mjs",
        "copy-assets": "node copy-assets.mjs"
    }
}
```

## üîß Development Tools

### Hot Reload System

```javascript
// Development hot reload functionality
export function triggerHotReload() {
    if (process.env.NODE_ENV === 'development') {
        // Create a file that the plugin watches for changes
        const fs = require('fs');
        const path = require('path');
        
        const reloadMarker = path.join(process.cwd(), '.reload-marker');
        fs.writeFileSync(reloadMarker, Date.now().toString());
        
        console.log('üîÑ Hot reload triggered');
    }
}

// In the main plugin file (main.ts)
export default class ELNPlugin extends Plugin {
    private hotReloadWatcher?: fs.FSWatcher;
    
    async onload() {
        // ... other initialization
        
        if (process.env.NODE_ENV === 'development') {
            this.setupHotReload();
        }
    }
    
    private setupHotReload() {
        const reloadMarker = path.join(this.app.vault.adapter.basePath, '.reload-marker');
        
        this.hotReloadWatcher = fs.watch(path.dirname(reloadMarker), (eventType, filename) => {
            if (filename === '.reload-marker') {
                console.log('üîÑ Hot reloading plugin...');
                
                // Reload the plugin
                this.app.plugins.disablePlugin(this.manifest.id).then(() => {
                    this.app.plugins.enablePlugin(this.manifest.id);
                });
            }
        });
    }
    
    onunload() {
        this.hotReloadWatcher?.close();
    }
}
```

### Bundle Analysis

```javascript
// Bundle analysis utility
export function analyzeBundleSize() {
    const fs = require('fs');
    const path = require('path');
    
    const bundlePath = 'main.js';
    
    if (!fs.existsSync(bundlePath)) {
        console.warn('Bundle file not found for analysis');
        return;
    }
    
    const stats = fs.statSync(bundlePath);
    const sizeKB = (stats.size / 1024).toFixed(2);
    
    console.log(`üì¶ Bundle size: ${sizeKB} KB`);
    
    // Size warnings
    if (stats.size > 1024 * 1024) { // 1MB
        console.warn('‚ö†Ô∏è  Bundle size is quite large (>1MB)');
    } else if (stats.size > 512 * 1024) { // 512KB
        console.warn('‚ö†Ô∏è  Bundle size is getting large (>512KB)');
    }
    
    // Generate size report
    generateSizeReport(stats.size);
}

function generateSizeReport(bundleSize) {
    const report = {
        timestamp: new Date().toISOString(),
        bundleSize,
        sizeKB: (bundleSize / 1024).toFixed(2),
        sizeMB: (bundleSize / (1024 * 1024)).toFixed(2)
    };
    
    // Read existing reports
    let reports = [];
    try {
        const reportsFile = 'build-reports.json';
        if (fs.existsSync(reportsFile)) {
            reports = JSON.parse(fs.readFileSync(reportsFile, 'utf8'));
        }
    } catch (error) {
        // Start fresh if file is corrupted
    }
    
    // Add new report
    reports.push(report);
    
    // Keep only last 100 reports
    if (reports.length > 100) {
        reports = reports.slice(-100);
    }
    
    // Write back
    fs.writeFileSync('build-reports.json', JSON.stringify(reports, null, 2));
}
```

## üè≠ Release Build Process

### Release Build Script

```javascript
// build-release.mjs
import fs from 'fs/promises';
import path from 'path';
import { execSync } from 'child_process';
import archiver from 'archiver';

export class ReleaseBuildProcess {
    constructor(options = {}) {
        this.version = options.version || this.getCurrentVersion();
        this.outputDir = options.outputDir || 'release';
        this.packageName = options.packageName || 'obsidian-eln-plugin';
    }
    
    async build() {
        console.log(`üöÄ Building release ${this.version}...`);
        
        try {
            // 1. Clean previous builds
            await this.clean();
            
            // 2. Run production build
            await this.buildProduction();
            
            // 3. Copy release files
            await this.copyReleaseFiles();
            
            // 4. Create package
            await this.createPackage();
            
            // 5. Verify package
            await this.verifyPackage();
            
            console.log(`‚úÖ Release ${this.version} built successfully!`);
            
        } catch (error) {
            console.error('‚ùå Release build failed:', error);
            throw error;
        }
    }
    
    getCurrentVersion() {
        const manifest = JSON.parse(fs.readFileSync('manifest.json', 'utf8'));
        return manifest.version;
    }
    
    async clean() {
        console.log('üßπ Cleaning previous builds...');
        
        try {
            await fs.rm(this.outputDir, { recursive: true, force: true });
            await fs.mkdir(this.outputDir, { recursive: true });
        } catch (error) {
            // Directory might not exist, which is fine
        }
    }
    
    async buildProduction() {
        console.log('üèóÔ∏è  Running production build...');
        
        // Build JavaScript
        execSync('node esbuild.config.mjs production', { stdio: 'inherit' });
        
        // Build CSS
        execSync('node build-css.mjs --minify', { stdio: 'inherit' });
    }
    
    async copyReleaseFiles() {
        console.log('üìÅ Copying release files...');
        
        const filesToCopy = [
            'main.js',
            'styles.css',
            'manifest.json'
        ];
        
        for (const file of filesToCopy) {
            const source = file;
            const destination = path.join(this.outputDir, file);
            
            try {
                await fs.copyFile(source, destination);
                console.log(`  ‚úì Copied ${file}`);
            } catch (error) {
                console.error(`  ‚úó Failed to copy ${file}:`, error.message);
                throw error;
            }
        }
    }
    
    async createPackage() {
        console.log('üì¶ Creating release package...');
        
        const packagePath = `${this.packageName}-${this.version}.zip`;
        
        return new Promise((resolve, reject) => {
            const output = fs.createWriteStream(packagePath);
            const archive = archiver('zip', { zlib: { level: 9 } });
            
            output.on('close', () => {
                const sizeKB = (archive.pointer() / 1024).toFixed(2);
                console.log(`  ‚úì Package created: ${packagePath} (${sizeKB} KB)`);
                resolve();
            });
            
            archive.on('error', reject);
            archive.pipe(output);
            
            // Add files from release directory
            archive.directory(this.outputDir, false);
            archive.finalize();
        });
    }
    
    async verifyPackage() {
        console.log('üîç Verifying package...');
        
        const packagePath = `${this.packageName}-${this.version}.zip`;
        
        // Check if package exists and has reasonable size
        const stats = await fs.stat(packagePath);
        const sizeKB = stats.size / 1024;
        
        if (sizeKB < 10) {
            throw new Error('Package seems too small - possibly incomplete');
        }
        
        if (sizeKB > 5000) {
            console.warn('‚ö†Ô∏è  Package is quite large (>5MB)');
        }
        
        console.log(`  ‚úì Package verification passed (${sizeKB.toFixed(2)} KB)`);
    }
}

// Version bump functionality
export class VersionBumper {
    constructor() {
        this.manifestPath = 'manifest.json';
        this.packagePath = 'package.json';
        this.versionsPath = 'versions.json';
    }
    
    async bump(type = 'patch') {
        console.log(`üìà Bumping ${type} version...`);
        
        // Read current versions
        const manifest = JSON.parse(await fs.readFile(this.manifestPath, 'utf8'));
        const packageJson = JSON.parse(await fs.readFile(this.packagePath, 'utf8'));
        
        // Calculate new version
        const newVersion = this.calculateNewVersion(manifest.version, type);
        
        // Update files
        manifest.version = newVersion;
        packageJson.version = newVersion;
        
        await fs.writeFile(this.manifestPath, JSON.stringify(manifest, null, 2));
        await fs.writeFile(this.packagePath, JSON.stringify(packageJson, null, 2));
        
        // Update versions.json
        await this.updateVersionsFile(newVersion, manifest.minAppVersion);
        
        console.log(`‚úÖ Version bumped to ${newVersion}`);
        return newVersion;
    }
    
    calculateNewVersion(currentVersion, type) {
        const parts = currentVersion.split('.').map(Number);
        
        switch (type) {
            case 'major':
                parts[0]++;
                parts[1] = 0;
                parts[2] = 0;
                break;
            case 'minor':
                parts[1]++;
                parts[2] = 0;
                break;
            case 'patch':
            default:
                parts[2]++;
                break;
        }
        
        return parts.join('.');
    }
    
    async updateVersionsFile(version, minAppVersion) {
        let versions = {};
        
        try {
            versions = JSON.parse(await fs.readFile(this.versionsPath, 'utf8'));
        } catch (error) {
            // File doesn't exist, start fresh
        }
        
        versions[version] = minAppVersion;
        
        await fs.writeFile(this.versionsPath, JSON.stringify(versions, null, 2));
    }
}

// Main execution
if (import.meta.url === `file://${process.argv[1]}`) {
    const releaseBuilder = new ReleaseBuildProcess();
    releaseBuilder.build().catch(console.error);
}
```

### Version Bump Script

```javascript
// version-bump.mjs
import { VersionBumper } from './build-release.mjs';

const type = process.argv[2] || 'patch';
const versionBumper = new VersionBumper();

versionBumper.bump(type).catch(console.error);
```

## üîÑ Asset Pipeline

### Asset Copy Script

```javascript
// copy-assets.mjs
import fs from 'fs/promises';
import path from 'path';

export class AssetPipeline {
    constructor() {
        this.sourceDir = 'assets';
        this.outputDir = 'release';
        this.manifestPath = 'manifest.json';
    }
    
    async copyAssets() {
        console.log('üìã Copying assets...');
        
        try {
            const manifest = JSON.parse(await fs.readFile(this.manifestPath, 'utf8'));
            
            // Copy required assets based on manifest
            if (manifest.assets) {
                for (const asset of manifest.assets) {
                    await this.copyAsset(asset);
                }
            }
            
            console.log('‚úÖ Assets copied successfully');
            
        } catch (error) {
            console.error('‚ùå Asset copy failed:', error);
            throw error;
        }
    }
    
    async copyAsset(assetPath) {
        const source = path.join(this.sourceDir, assetPath);
        const destination = path.join(this.outputDir, assetPath);
        
        // Ensure destination directory exists
        await fs.mkdir(path.dirname(destination), { recursive: true });
        
        // Copy file
        await fs.copyFile(source, destination);
        console.log(`  ‚úì Copied ${assetPath}`);
    }
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
    const pipeline = new AssetPipeline();
    pipeline.copyAssets().catch(console.error);
}
```

## üîó Vault Synchronization

### Sync Script for Development

```javascript
// sync-from-vault.mjs
import fs from 'fs/promises';
import path from 'path';

export class VaultSyncer {
    constructor(options = {}) {
        this.vaultPath = options.vaultPath || process.env.TEST_VAULT_PATH;
        this.pluginId = options.pluginId || 'obsidian-eln-plugin';
    }
    
    async sync() {
        if (!this.vaultPath) {
            console.log('‚ÑπÔ∏è  No vault path configured, skipping sync');
            return;
        }
        
        console.log(`üîÑ Syncing to vault: ${this.vaultPath}`);
        
        try {
            const pluginDir = path.join(this.vaultPath, '.obsidian', 'plugins', this.pluginId);
            
            // Ensure plugin directory exists
            await fs.mkdir(pluginDir, { recursive: true });
            
            // Copy built files
            const filesToSync = ['main.js', 'styles.css', 'manifest.json'];
            
            for (const file of filesToSync) {
                const source = file;
                const destination = path.join(pluginDir, file);
                
                try {
                    await fs.copyFile(source, destination);
                    console.log(`  ‚úì Synced ${file}`);
                } catch (error) {
                    console.warn(`  ‚ö†Ô∏è  Could not sync ${file}:`, error.message);
                }
            }
            
            console.log('‚úÖ Sync completed');
            
        } catch (error) {
            console.error('‚ùå Sync failed:', error);
            throw error;
        }
    }
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
    const syncer = new VaultSyncer();
    syncer.sync().catch(console.error);
}
```

## üõ†Ô∏è Build Monitoring

### Health Check Script

```bash
#!/bin/bash
# scripts/health-check.sh

echo "üè• Running build health check..."

# Check if required files exist
required_files=("main.js" "styles.css" "manifest.json")
missing_files=()

for file in "${required_files[@]}"; do
    if [ ! -f "$file" ]; then
        missing_files+=("$file")
    fi
done

if [ ${#missing_files[@]} -gt 0 ]; then
    echo "‚ùå Missing required files:"
    printf '  - %s\n' "${missing_files[@]}"
    exit 1
fi

# Check file sizes
main_size=$(stat -f%z main.js 2>/dev/null || stat -c%s main.js 2>/dev/null)
styles_size=$(stat -f%z styles.css 2>/dev/null || stat -c%s styles.css 2>/dev/null)

if [ "$main_size" -lt 1000 ]; then
    echo "‚ö†Ô∏è  main.js seems too small ($main_size bytes)"
fi

if [ "$styles_size" -lt 100 ]; then
    echo "‚ö†Ô∏è  styles.css seems too small ($styles_size bytes)"
fi

# Check syntax
echo "üîç Checking JavaScript syntax..."
if ! node -c main.js 2>/dev/null; then
    echo "‚ùå JavaScript syntax error in main.js"
    exit 1
fi

# Check manifest validity
echo "üîç Checking manifest..."
if ! node -e "JSON.parse(require('fs').readFileSync('manifest.json', 'utf8'))" 2>/dev/null; then
    echo "‚ùå Invalid JSON in manifest.json"
    exit 1
fi

echo "‚úÖ Build health check passed"
```

## üìä Performance Monitoring

### Build Performance Tracking

```javascript
// performance-monitor.mjs
export class BuildPerformanceMonitor {
    constructor() {
        this.metrics = {
            buildStart: null,
            buildEnd: null,
            phases: {}
        };
    }
    
    startBuild() {
        this.metrics.buildStart = Date.now();
        console.log('‚è±Ô∏è  Build started');
    }
    
    startPhase(phase) {
        this.metrics.phases[phase] = { start: Date.now() };
        console.log(`‚è±Ô∏è  Starting ${phase}...`);
    }
    
    endPhase(phase) {
        if (this.metrics.phases[phase]) {
            this.metrics.phases[phase].end = Date.now();
            const duration = this.metrics.phases[phase].end - this.metrics.phases[phase].start;
            console.log(`‚úÖ ${phase} completed in ${duration}ms`);
        }
    }
    
    endBuild() {
        this.metrics.buildEnd = Date.now();
        const totalDuration = this.metrics.buildEnd - this.metrics.buildStart;
        
        console.log(`üèÅ Build completed in ${totalDuration}ms`);
        
        // Log phase breakdown
        console.log('\nüìä Phase breakdown:');
        for (const [phase, times] of Object.entries(this.metrics.phases)) {
            if (times.end) {
                const duration = times.end - times.start;
                const percentage = ((duration / totalDuration) * 100).toFixed(1);
                console.log(`  ${phase}: ${duration}ms (${percentage}%)`);
            }
        }
        
        // Save metrics for analysis
        this.saveMetrics();
    }
    
    async saveMetrics() {
        const fs = require('fs').promises;
        
        try {
            let history = [];
            try {
                const data = await fs.readFile('build-metrics.json', 'utf8');
                history = JSON.parse(data);
            } catch {
                // File doesn't exist, start fresh
            }
            
            history.push({
                timestamp: new Date().toISOString(),
                ...this.metrics
            });
            
            // Keep only last 50 builds
            if (history.length > 50) {
                history = history.slice(-50);
            }
            
            await fs.writeFile('build-metrics.json', JSON.stringify(history, null, 2));
        } catch (error) {
            console.warn('Could not save build metrics:', error.message);
        }
    }
}
```

This comprehensive build system provides a robust, efficient development workflow with modern tooling, optimized builds, and extensive monitoring capabilities for the Obsidian ELN Plugin.
