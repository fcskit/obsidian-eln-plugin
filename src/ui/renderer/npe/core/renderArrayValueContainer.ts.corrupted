import { getDataType, getTypeDisplayName, convertArrayItemInput } from "../helpers/getDataType";
import { getFrontmatterValue } from "../helpers/getFrontmatterValue";
import { updateProperties } from "../utils/updateProperties";
import { createInternalLinkElement } from "../elements/createInternalLinkElement";
import { createExternalLinkElement } from "../elements/createExternalLinkElement";
import { latexToHTML } from "../helpers/latexUtils";
import { createLogger } from "../../../../utils/Logger";
import { setTooltip } from "obsidian";

const logger = createLogger('npe');

/**
 * Renders a single array item with all its interaction handlers.
 * This function is used both for initial rendering and selective re-rendering of individual items.
 */
function renderSingleArrayItem(
    view: NestedPropertiesEditorView | NestedPropertiesEditorCodeBlockView,
    item: FrontmatterValue,
    index: number,
    fullKey: string,
    level: number,
    parentContainer: HTMLElement
): HTMLElement {
    const key = fullKey.split('.').pop();
    const itemDataType = getDataType(item);
    
    const itemContainer = parentContainer.createDiv({ 
        cls: 'npe-list-item',
        attr: { 
            'data-key': `${fullKey}.${index}`,
            'data-type': itemDataType
        }
    });
    
    if (key === 'tags' || key === 'tag') {
        itemContainer.addClass('npe-tag-item');
    }

    // Add type tooltip to the list item
    addTypeTooltip(view, itemContainer, itemDataType, item);

    if (itemDataType === 'link') {
        const linkValue = typeof item === 'string' ? item.slice(2, -2) : String(item);
        createInternalLinkElement(view, linkValue, itemContainer, itemContainer.getAttribute('data-key') || `${fullKey}.${index}`);
    } else if (itemDataType === 'external-link') {
        const linkValue = typeof item === 'string' ? item : String(item);
        createExternalLinkElement(view, linkValue, itemContainer, itemContainer.getAttribute('data-key') || `${fullKey}.${index}`);
    } else if (itemDataType === 'latex') {
        const latexValue = typeof item === 'string' ? item.slice(1, -1) : String(item);
        const latexDisplay = itemContainer.createDiv({ cls: 'npe-list-item-latex' });
        latexDisplay.innerHTML = latexToHTML(latexValue);
        // Add contentEditable support for latex editing
        latexDisplay.contentEditable = "true";
        view.registerDomEvent(latexDisplay, 'blur', () => {
            const currentDataKey = itemContainer.getAttribute('data-key') || `${fullKey}.${index}`;
            if (view.currentFile) {
                // Set internal change flag BEFORE calling updateProperties
                if (view instanceof NestedPropertiesEditorView) {
                    view.setInternalChangeFlag();
                }
                // Use standard updateProperties function
                updateProperties(view.app, view.currentFile, currentDataKey, latexDisplay.textContent, itemDataType);
            }
        });
    } else if (itemDataType === 'array') {
        // Handle nested arrays by rendering them as proper nested structures
        if (Array.isArray(item)) {
            const nestedArrayContainer = itemContainer.createDiv({ 
                cls: 'npe-nested-array-container',
                attr: { 'data-key': `${fullKey}.${index}` }
            });
            renderArray(view, `item ${index + 1}`, item as Array<FrontmatterValue>, nestedArrayContainer, level + 1, `${fullKey}.${index}`, [], false);
        }
    } else if (itemDataType === 'object') {
        // Handle nested objects by rendering them as proper nested structures  
        if (typeof item === 'object' && item !== null && !Array.isArray(item)) {
            const nestedObjectContainer = itemContainer.createDiv({ 
                cls: 'npe-nested-object-container',
                attr: { 'data-key': `${fullKey}.${index}` }
            });
            renderObjectContainer(view, `item ${index + 1}`, item as FrontmatterObject, nestedObjectContainer, level + 1, `${fullKey}.${index}`, []);
        }
    } else if (itemDataType === 'string' || itemDataType === 'number') {
        const input = itemContainer.createDiv({ cls: 'npe-list-item-value', text: String(item) });
        input.contentEditable = "true";
        view.registerDomEvent(input, 'blur', () => {
            // Read the current data-key from the container to handle dynamic array changes
            const currentDataKey = itemContainer.getAttribute('data-key') || `${fullKey}.${index}`;
            if (view.currentFile) {
                // Set internal change flag BEFORE calling updateProperties
                if (view instanceof NestedPropertiesEditorView) {
                    view.setInternalChangeFlag();
                }
                
                // Use intelligent type conversion for array items
                const userInput = input.textContent || '';
                const currentItem = typeof item === 'object' && item !== null && !Array.isArray(item) 
                    ? undefined 
                    : item as FrontmatterPrimitive | undefined;
                // Get the current data-type from the container's attribute, not the original itemDataType
                const currentDataType = itemContainer.getAttribute('data-type') || itemDataType;
                const conversionResult = convertArrayItemInput(userInput, currentDataType, currentItem);
                
                // Update the data-type attribute if type changed
                if (conversionResult.typeChanged) {
                    itemContainer.setAttribute('data-type', conversionResult.detectedType);
                    // Update tooltip if shown
                    if (view.plugin?.settings?.npe?.showDataTypes) {
                        const displayName = getTypeDisplayName(conversionResult.detectedType);
                        const tooltipText = `Data type: ${displayName} (converted from ${getTypeDisplayName(conversionResult.originalType)})`;
                        setTooltip(itemContainer, tooltipText, {
                            delay: 2000,
                            placement: 'top'
                        });
                    }
                    logger.debug(`Array item type converted from ${conversionResult.originalType} to ${conversionResult.detectedType}`, {
                        userInput,
                        convertedValue: conversionResult.convertedValue
                    });
                }
                
                // Use the converted value and detected type for storage
                updateProperties(
                    view.app, 
                    view.currentFile, 
                    currentDataKey, 
                    conversionResult.convertedValue, 
                    conversionResult.detectedType
                );
                
                // Re-render just this specific item if type changed
                if (conversionResult.typeChanged) {
                    rerenderSingleArrayItem(view, itemContainer, fullKey, index, level);
                }
            }
        });
    } else if (itemDataType === 'boolean') {
        // ... rest will be similar to existing boolean rendering logic
    } else if (itemDataType === 'date') {
        // ... rest will be similar to existing date rendering logic
    }

    return itemContainer;
}

/**
 * Re-renders a single array item after a type change.
 * This preserves the editing context while updating the item structure.
 */
function rerenderSingleArrayItem(
    view: NestedPropertiesEditorView | NestedPropertiesEditorCodeBlockView,
    itemContainer: HTMLElement,
    fullKey: string,
    index: number,
    level: number
): void {
    // Wait for metadata update to complete
    setTimeout(() => {
        // Get the updated value from frontmatter
        const arrayKey = fullKey.split('.').slice(0, -1).join('.');
        const currentArray = getFrontmatterValue(view.app, arrayKey);
        
        if (Array.isArray(currentArray) && currentArray[index] !== undefined) {
            const updatedItem = currentArray[index];
            const parentContainer = itemContainer.parentElement;
            
            if (parentContainer) {
                // Remove the old item container
                itemContainer.remove();
                
                // Create a new item container in the same position
                const newItemContainer = renderSingleArrayItem(view, updatedItem, index, fullKey, level, parentContainer);
                
                // Insert at the correct position relative to siblings
                const siblings = Array.from(parentContainer.children);
                if (index < siblings.length) {
                    parentContainer.insertBefore(newItemContainer, siblings[index]);
                } else {
                    parentContainer.appendChild(newItemContainer);
                }
            }
        }
    }, 50);
}

export function renderArrayValueContainer(
    view: NestedPropertiesEditorView | NestedPropertiesEditorCodeBlockView,
    valueContainer: HTMLElement,
    array: Array<FrontmatterValue>,
    fullKey: string,
    level: number = 0
) {
    const app = view.app;
    
    array.forEach((item, index) => {
        renderSingleArrayItem(view, item, index, fullKey, level, valueContainer);
    });

    // --- Add Button ---
    const addButton = valueContainer.createDiv({ cls: 'npe-button npe-button--add', text: '+' });
    view.registerDomEvent(addButton, 'click', () => {
        // Get current array from the frontmatter (like old JS version)
        const currentArray = getFrontmatterValue(app, fullKey);
        if (Array.isArray(currentArray)) {
            const newItem = 'new item';
            currentArray.push(newItem);
            // Clear content of the value container and re-render (like old JS version)
            valueContainer.innerHTML = '';
            renderArrayValueContainer(view, valueContainer, currentArray as Array<FrontmatterValue>, fullKey, level);
            // Use standard updateProperties function
            if (view.currentFile) {
                // Set internal change flag BEFORE calling updateProperties
                if (view instanceof NestedPropertiesEditorView) {
                    view.setInternalChangeFlag();
                }
                updateProperties(view.app, view.currentFile, fullKey, currentArray, 'array');
            }
        }
    });
}

// Now I need to add the missing imports that were corrupted
import { createEditableDiv } from "../elements/createEditableDiv";
import { renderArray } from "./renderArray";
import { renderObjectContainer } from "./renderObjectContainer";
import { NestedPropertiesEditorView } from "../../../views/NestedPropertiesEditor";
import type { NestedPropertiesEditorCodeBlockView } from "../../../views/NestedPropertiesEditor";
import type { FrontmatterValue, FrontmatterObject, FrontmatterPrimitive } from "../../../../types/core";

/**
 * Adds a tooltip to array items showing their data type.
 * Only adds tooltip if the plugin setting is enabled.
 */
function addTypeTooltip(
    view: NestedPropertiesEditorView | NestedPropertiesEditorCodeBlockView,
    element: HTMLElement,
    dataType: string,
    value: FrontmatterValue
): void {
    const showTypeLabels = view.plugin?.settings?.npe?.showDataTypes || false;
    
    if (!showTypeLabels) {
        return;
    }

    // Don't show tooltips for arrays and objects as they're obvious from structure
    if (dataType === 'array' || dataType === 'object' || dataType === 'unknown') {
        return;
    }

    // Get display name for the type using unified function
    const displayName = getTypeDisplayName(dataType);
    const tooltipText = `Data type: ${displayName}`;
    
    // Add tooltip with 2 second delay to avoid interference with editing
    setTooltip(element, tooltipText, {
        delay: 2000,
        placement: 'top'
    });
}

        if (itemDataType === 'link') {
            const linkValue = typeof item === 'string' ? item.slice(2, -2) : String(item);
            createInternalLinkElement(view, linkValue, itemContainer, itemContainer.getAttribute('data-key') || `${fullKey}.${index}`);
        } else if (itemDataType === 'external-link') {
            const linkValue = typeof item === 'string' ? item : String(item);
            createExternalLinkElement(view, linkValue, itemContainer, itemContainer.getAttribute('data-key') || `${fullKey}.${index}`);
        } else if (itemDataType === 'latex') {
            const latexValue = typeof item === 'string' ? item.slice(1, -1) : String(item);
            const latexDisplay = itemContainer.createDiv({ cls: 'npe-list-item-latex' });
            latexDisplay.innerHTML = latexToHTML(latexValue);
            // Add contentEditable support for latex editing
            latexDisplay.contentEditable = "true";
            view.registerDomEvent(latexDisplay, 'blur', () => {
                const currentDataKey = itemContainer.getAttribute('data-key') || `${fullKey}.${index}`;
                if (view.currentFile) {
                    // Set internal change flag BEFORE calling updateProperties
                    if (view instanceof NestedPropertiesEditorView) {
                        view.setInternalChangeFlag();
                    }
                    // Use standard updateProperties function
                    updateProperties(view.app, view.currentFile, currentDataKey, latexDisplay.textContent, itemDataType);
                }
            });
        } else if (itemDataType === 'array') {
            // Handle nested arrays by rendering them as proper nested structures
            if (Array.isArray(item)) {
                const nestedArrayContainer = itemContainer.createDiv({ 
                    cls: 'npe-nested-array-container',
                    attr: { 'data-key': `${fullKey}.${index}` }
                });
                renderArray(view, `item ${index + 1}`, item as Array<FrontmatterValue>, nestedArrayContainer, level + 1, `${fullKey}.${index}`, [], false);
            }
        } else if (itemDataType === 'object') {
            // Handle nested objects by rendering them as proper nested structures  
            if (typeof item === 'object' && item !== null && !Array.isArray(item)) {
                const nestedObjectContainer = itemContainer.createDiv({ 
                    cls: 'npe-nested-object-container',
                    attr: { 'data-key': `${fullKey}.${index}` }
                });
                renderObjectContainer(view, `item ${index + 1}`, item as FrontmatterObject, nestedObjectContainer, level + 1, `${fullKey}.${index}`, []);
            }
        } else if (itemDataType === 'string' || itemDataType === 'number') {
            const input = itemContainer.createDiv({ cls: 'npe-list-item-value', text: String(item) });
            input.contentEditable = "true";
            view.registerDomEvent(input, 'blur', () => {
                // Read the current data-key from the container to handle dynamic array changes
                const currentDataKey = itemContainer.getAttribute('data-key') || `${fullKey}.${index}`;
                if (view.currentFile) {
                    // Set internal change flag BEFORE calling updateProperties
                    if (view instanceof NestedPropertiesEditorView) {
                        view.setInternalChangeFlag();
                    }
                    
                    // Use intelligent type conversion for array items
                    const userInput = input.textContent || '';
                    const currentItem = typeof item === 'object' && item !== null && !Array.isArray(item) 
                        ? undefined 
                        : item as FrontmatterPrimitive | undefined;
                    // Get the current data-type from the container's attribute, not the original itemDataType
                    const currentDataType = itemContainer.getAttribute('data-type') || itemDataType;
                    const conversionResult = convertArrayItemInput(userInput, currentDataType, currentItem);
                    
                    // Update the data-type attribute if type changed
                    if (conversionResult.typeChanged) {
                        itemContainer.setAttribute('data-type', conversionResult.detectedType);
                        // Update tooltip if shown
                        if (view.plugin?.settings?.npe?.showDataTypes) {
                            const displayName = getTypeDisplayName(conversionResult.detectedType);
                            const tooltipText = `Data type: ${displayName} (converted from ${getTypeDisplayName(conversionResult.originalType)})`;
                            setTooltip(itemContainer, tooltipText, {
                                delay: 2000,
                                placement: 'top'
                            });
                        }
                        logger.debug(`Array item type converted from ${conversionResult.originalType} to ${conversionResult.detectedType}`, {
                            userInput,
                            convertedValue: conversionResult.convertedValue
                        });
                    }
                    
                    // Use the converted value and detected type for storage
                    updateProperties(
                        view.app, 
                        view.currentFile, 
                        currentDataKey, 
                        conversionResult.convertedValue, 
                        conversionResult.detectedType
                    );
                    
                    // Always re-render the entire array if type changed (simpler and more reliable)
                    if (conversionResult.typeChanged) {
                        // Wait to ensure frontmatter update is complete
                        setTimeout(() => {
                            // Get current array and re-render
                            const currentArray = getFrontmatterValue(app, fullKey);
                            if (Array.isArray(currentArray)) {
                                valueContainer.innerHTML = '';
                                renderArrayValueContainer(view, valueContainer, currentArray as Array<FrontmatterValue>, fullKey, level);
                            }
                        }, 50);
                    }
                }
            });
        } else {
            let inputType: string;
            switch (itemDataType) {
                case 'date':
                    inputType = 'date';
                    break;
                case 'boolean':
                    inputType = 'checkbox';
                    break;
                default:
                    inputType = 'text';
            }
            
            // Use editable divs for text/number inputs, HTML inputs for date/checkbox
            if (inputType === 'text' || inputType === 'number') {
                const editableDiv = createEditableDiv(
                    itemContainer,
                    String(item),
                    `Enter ${inputType === "number" ? "number" : "text"}...`,
                    inputType as "text" | "number",
                    (newValue) => {
                        const currentDataKey = itemContainer.getAttribute('data-key') || `${fullKey}.${index}`;
                        logger.debug(`Array item editable div callback fired: ${currentDataKey} = ${newValue} (type: ${itemDataType})`);
                        if (view.currentFile) {
                            // Set internal change flag BEFORE calling updateProperties
                            if (view instanceof NestedPropertiesEditorView) {
                                view.setInternalChangeFlag();
                            }
                            
                            // Use intelligent type conversion for array items
                            const currentItem = typeof item === 'object' && item !== null && !Array.isArray(item) 
                                ? undefined 
                                : item as FrontmatterPrimitive | undefined;
                            // Get the current data-type from the container's attribute, not the original itemDataType
                            const currentDataType = itemContainer.getAttribute('data-type') || itemDataType;
                            const conversionResult = convertArrayItemInput(String(newValue), currentDataType, currentItem);
                            
                            // Update the data-type attribute if type changed
                            if (conversionResult.typeChanged) {
                                itemContainer.setAttribute('data-type', conversionResult.detectedType);
                                editableDiv.setAttribute('data-type', conversionResult.detectedType);
                                // Update tooltip if shown
                                if (view.plugin?.settings?.npe?.showDataTypes) {
                                    const displayName = getTypeDisplayName(conversionResult.detectedType);
                                    const tooltipText = `Data type: ${displayName} (converted from ${getTypeDisplayName(conversionResult.originalType)})`;
                                    setTooltip(itemContainer, tooltipText, {
                                        delay: 2000,
                                        placement: 'top'
                                    });
                                }
                                logger.debug(`Array item type converted from ${conversionResult.originalType} to ${conversionResult.detectedType}`, {
                                    newValue,
                                    convertedValue: conversionResult.convertedValue
                                });
                            }
                            
                            // Use the converted value and detected type for storage
                            updateProperties(
                                view.app, 
                                view.currentFile, 
                                currentDataKey, 
                                conversionResult.convertedValue, 
                                conversionResult.detectedType
                            );
                            
                            // Always re-render the entire array if type changed (simpler and more reliable)
                            if (conversionResult.typeChanged) {
                                // Wait to ensure frontmatter update is complete
                                setTimeout(() => {
                                    // Get current array and re-render
                                    const currentArray = getFrontmatterValue(app, fullKey);
                                    if (Array.isArray(currentArray)) {
                                        valueContainer.innerHTML = '';
                                        renderArrayValueContainer(view, valueContainer, currentArray as Array<FrontmatterValue>, fullKey, level);
                                    }
                                }, 50);
                            }
                        }
                        // Update the current array from frontmatter (better approach than modifying passed array)
                        const currentArray = getFrontmatterValue(app, fullKey);
                        if (Array.isArray(currentArray) && currentArray[index] !== undefined) {
                            currentArray[index] = newValue;
                        }
                    }
                );
                editableDiv.setAttribute('data-key', `${fullKey}.${index}`);
                editableDiv.setAttribute('data-type', itemDataType);
            } else {
                // Use traditional HTML input for date, checkbox, and other input types
                const input = itemContainer.createEl('input', {
                    type: inputType,
                    value: typeof item === 'string' || typeof item === 'number' ? String(item) : '',
                    attr: { 'data-key': `${fullKey}.${index}`, 'data-type': itemDataType }
                });
                input.oninput = () => {
                    const currentDataKey = itemContainer.getAttribute('data-key') || `${fullKey}.${index}`;
                    if (view.currentFile) {
                        // Set internal change flag BEFORE calling updateProperties
                        if (view instanceof NestedPropertiesEditorView) {
                            view.setInternalChangeFlag();
                        }
                        
                        // Use intelligent type conversion for array items
                        const currentItem = typeof item === 'object' && item !== null && !Array.isArray(item) 
                            ? undefined 
                            : item as FrontmatterPrimitive | undefined;
                        // Get the current data-type from the container's attribute, not the original itemDataType
                        const currentDataType = itemContainer.getAttribute('data-type') || itemDataType;
                        const conversionResult = convertArrayItemInput(input.value, currentDataType, currentItem);
                        
                        // Update the data-type attribute if type changed
                        if (conversionResult.typeChanged) {
                            itemContainer.setAttribute('data-type', conversionResult.detectedType);
                            input.setAttribute('data-type', conversionResult.detectedType);
                            // Update tooltip if shown
                            if (view.plugin?.settings?.npe?.showDataTypes) {
                                const displayName = getTypeDisplayName(conversionResult.detectedType);
                                const tooltipText = `Data type: ${displayName} (converted from ${getTypeDisplayName(conversionResult.originalType)})`;
                                setTooltip(itemContainer, tooltipText, {
                                    delay: 2000,
                                    placement: 'top'
                                });
                            }
                            logger.debug(`Array item type converted from ${conversionResult.originalType} to ${conversionResult.detectedType}`, {
                                inputValue: input.value,
                                convertedValue: conversionResult.convertedValue
                            });
                        }
                        
                        // Use the converted value and detected type for storage
                        updateProperties(
                            view.app, 
                            view.currentFile, 
                            currentDataKey, 
                            conversionResult.convertedValue, 
                            conversionResult.detectedType
                        );
                        
                        // Always re-render the entire array if type changed (simpler and more reliable)
                        if (conversionResult.typeChanged) {
                            // Wait to ensure frontmatter update is complete
                            setTimeout(() => {
                                // Get current array and re-render
                                const currentArray = getFrontmatterValue(app, fullKey);
                                if (Array.isArray(currentArray)) {
                                    valueContainer.innerHTML = '';
                                    renderArrayValueContainer(view, valueContainer, currentArray as Array<FrontmatterValue>, fullKey, level);
                                }
                            }, 50);
                        }
                    }
                    // Update the current array from frontmatter (better approach than modifying passed array)
                    const currentArray = getFrontmatterValue(app, fullKey);
                    if (Array.isArray(currentArray) && currentArray[index] !== undefined) {
                        currentArray[index] = input.value;
                    }
                };
            }
        }

        // --- Remove Button for Array Item ---
        const removeButton = itemContainer.createDiv({ cls: 'npe-button npe-button--remove', text: 'Ã—' });
        view.registerDomEvent(removeButton, 'click', () => {
            // Get current array from the frontmatter (like old JS version)
            const currentArray = getFrontmatterValue(app, fullKey);
            if (Array.isArray(currentArray)) {
                currentArray.splice(index, 1);
                // Clear content of the value container and re-render (like old JS version)
                valueContainer.innerHTML = '';
                renderArrayValueContainer(view, valueContainer, currentArray as Array<FrontmatterValue>, fullKey, level);
                // Use standard updateProperties function
                if (view.currentFile) {
                    // Set internal change flag BEFORE calling updateProperties
                    if (view instanceof NestedPropertiesEditorView) {
                        view.setInternalChangeFlag();
                    }
                    updateProperties(view.app, view.currentFile, fullKey, currentArray, 'array');
                }
            }
        });
    });

    // --- Add Button ---
    const addButton = valueContainer.createDiv({ cls: 'npe-button npe-button--add', text: '+' });
    view.registerDomEvent(addButton, 'click', () => {
        // Get current array from the frontmatter (like old JS version)
        const currentArray = getFrontmatterValue(app, fullKey);
        if (Array.isArray(currentArray)) {
            const newItem = 'new item';
            currentArray.push(newItem);
            // Clear content of the value container and re-render (like old JS version)
            valueContainer.innerHTML = '';
            renderArrayValueContainer(view, valueContainer, currentArray as Array<FrontmatterValue>, fullKey, level);
            // Use standard updateProperties function
            if (view.currentFile) {
                // Set internal change flag BEFORE calling updateProperties
                if (view instanceof NestedPropertiesEditorView) {
                    view.setInternalChangeFlag();
                }
                updateProperties(view.app, view.currentFile, fullKey, currentArray, 'array');
            }
        }
    });
}

/**
 * Adds a tooltip to array items showing their data type.
 * Only adds tooltip if the plugin setting is enabled.
 */
function addTypeTooltip(
    view: NestedPropertiesEditorView | NestedPropertiesEditorCodeBlockView,
    element: HTMLElement,
    dataType: string,
    value: FrontmatterValue
): void {
    const showTypeLabels = view.plugin?.settings?.npe?.showDataTypes || false;
    
    if (!showTypeLabels) {
        return;
    }

    // Don't show tooltips for arrays and objects as they're obvious from structure
    if (dataType === 'array' || dataType === 'object' || dataType === 'unknown') {
        return;
    }

    // Get display name for the type using unified function
    const displayName = getTypeDisplayName(dataType);
    const tooltipText = `Data type: ${displayName}`;
    
    // Add tooltip with 2 second delay to avoid interference with editing
    setTooltip(element, tooltipText, {
        delay: 2000,
        placement: 'top'
    });
}